#   -*- mode: python; coding: utf-8; -*-
#
#   Copyright 2018 Asier Aguirre <asier.aguirre@gmail.com>
#   This file is part of memory-tools.
#
#   memory-tools is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   memory-tools is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with memory-tools. If not, see <http://www.gnu.org/licenses/>.

import mt_visitor, mt_colors as c, mt_maps

class MTmemory(mt_visitor.MTvisitor):
    def __init__(self):
        super().__init__()
        self.seen = { }   # { (addr, typename): (name, size) }
        self.graph = { }  # { (addr_from, addr_to): name }

    def analysis(self, symbols):
        """ memory analysis; symbols is a MTsymbols object """
        for addr, (symbol, value) in symbols.symbols.items():
            # start recursion for this value
            self.stack = [] # [ (name, address) ]
            self.visit(value, symbol.name)
            assert len(self.stack) == 1, 'memory analysis value'

    def dump(self):
        regions = mt_maps.MTmaps().regions
        regions.append([1 << 64, 1 << 64, ''])
        region = ''
        i_region = 0

        addrs = [ (addr, size, name, typename) for (addr, typename), (name, size) in self.seen.items() ]
        addrs = sorted(addrs, key = lambda x: (x[0] << 16) - x[1])
        max_segment = (0, 0)
        print(c.WHITE + 'Memory: ' + c.RESET + str(len(self.seen)) + ' values ' + str(len(self.graph)) + ' links')
        for i, (addr, size, name, typename) in enumerate(addrs):
            # region
            i_region_prev = i_region
            while addr >= regions[i_region][1]:
                i_region += 1
                region = regions[i_region][2]
            if region and i_region != i_region_prev:
                print(c.CYAN + 'region: ' + c.RESET + region)

            indent = 0
            j = i - 1
            while j >= 0 and addr >= max_segment[0]:
                if addr < addrs[j][0] + addrs[j][1]:
                    indent += 1
                j -= 1
            if addr + size > max_segment[1]:
                max_segment = (addr, addr + size)
            print((c.GREEN + '%16x ' + c.YELLOW + '%6d ' + c.RESET + '%s %s') % (addr, size, '    '*indent, name))

        print('\n' + c.WHITE + 'Links: ' + c.RESET)
        for (addr_from, addr_to), name in self.graph.items():
            print((c.GREEN + '%16x %16x ' + c.RESET + '%s') % (addr_from, addr_to, name))
        print()

    def autogenerated(self, name):
        return not name or (not name[0].isalpha() and not name[0] == '_')

    def process(self, value, name, recur):
        addr = int(value.address or 0)
        if addr:
            typename = str(value.type)
            key = (addr, typename)
            if key not in self.seen.keys():
                size = value.type.sizeof
                self.seen[key] = (name, size)
                if recur: # visit dependencies
                    # check for char[]
                    if self.is_string_char_array(value): return self.visit_string(value, name)

                    stack = self.stack
                    self.stack = []

                    # check for known structs
                    wrap = self.get_struct_wrapper(value)
                    if wrap:
                        # wrap iteration
                        count = 0
                        for item in wrap:
                            self.visit(item, ('[%d]' + name) % count)
                            count += 1
                            self.process_stack(addr, size)
                    else:
                        # generic visit
                        self.generic_visit(value, name)
                        self.process_stack(addr, size)

                    self.stack = stack
            elif not self.autogenerated(name):
                # update as name is adequate
                self.seen[key] = (name, value.type.sizeof)

        self.stack.append((name, addr))

    def process_stack(self, addr, size):
        for name_stack, address in self.stack:
            if address and (address < addr or address >= addr + size) and self.autogenerated(name_stack):
                self.graph[(addr, address)] = name_stack

    def visit_string (self, value, name):
        try:
            address = int(value.dereference().address)
        except:
            address = 0
        self.stack.append(('*' + name, address))

    def visit_struct (self, value, name): self.process(value, name, True)
    def visit_array  (self, value, name): self.process(value, name, True)
    def visit_union  (self, value, name): self.process(value, name, False) # too dangerous to recurse
    def visit_ptr    (self, value, name): self.process(value, name, True)
    def visit_ref    (self, value, name): self.process(value, name, True)
    def visit_int    (self, value, name): self.process(value, name, False)
    def visit_char   (self, value, name): self.process(value, name, False)
    def visit_bool   (self, value, name): self.process(value, name, False)
    def visit_flt    (self, value, name): self.process(value, name, False)
    def visit_enum   (self, value, name): self.process(value, name, False)
